# Dynamic data

Muban is designed to work with HTML that is fully generated by the server, where it only provides
the `JavaScript` and `CSS` to make the website look and work the way it should. The big downside is
that it's not possible to work with data-binding template engines that frameworks like
[Vue](https://vuejs.org/), [React](https://reactjs.org/) and [Angular](https://angular.io/) do,
because they have control over the HTML.

This means we create (interactive) components by passing the HTML element, and the component should
use querySelectors and other DOM APIs to read from and write to the DOM.

> **Note:** Usually this is enough but if you want to do more complex logic you are can load
> Knockout and use their full library to do data-bindings from within JavaScript. See the page about
> Knockout for more information.\*

## Data provider

There are multiple ways of providing the dynamic data to the component. Here we will discuss the
most common ones.

In this case, dynamic data is everything that is not rendered as visible HTML. There are different
ways to pass down additional data to the browser so it can be used by JavaScript upon user
interaction. See the tutorial section for a detailed instruction on how to do this.

- [data-attributes](./13-guides.md#Get-data-from-data-attributes)
- [embedded json](./13-guides.md#Get-data-from-embedded-json)
- [http-requests](./13-guides.md#Get-data-through-a-http-request)

## Data templates

Getting the dynamic data is just the first part, we also need to display the data on the screen.

There are several ways to get this done, and choosing one depends on the complexity of the data and
the template itself.

The following scenarios can occur:

- moving around existing items in the DOM
- toggling visibility of different parts of the DOM
- updating an existing view / item
- adding new items based on an existing template
- adding new items without an existing template

### Moving around existing items in the DOM

This could happen when you render all items on the server, and having a client-side sort/filter.

In this case you could simply pull all item DOM nodes from the container, extract the needed
information to apply a sort/filter, and add the resulting items back in the DOM.

### Toggling visibility of different parts of the DOM

This could happen when you have multiple views (e.g. a TabBar) that are all rendered on the server,
but in the client you only show the 'active' view, and hide the other ones.

### Updating an existing view / item

This could happen when you have a detail view, and you want to show a different variant without
reloading the page.

### Adding new items based on an existing template

This could happen when you have a 'Load More' button to do client-side pagination.

An existing template could be one of a few things:

- An existing DOM element of the item, we can then clone the element and update the content with
  setting textContent or innerHTML.
- Rendering a `template` element (display:none, without any content), and use that the same way as
  above.
- Reusing the `.hbs` template in the JS bundle, by calling the renderItem/renderItems methods from
  muban-core.
- Creating a knockout template and render those. Normally the hbs templates are preferred, but if
  you have additional logic to execute, this will be a nice solution. Or if you never render any
  template on the server, and already include the knockout lib in your project, this is also fine.

The main thing you want to minimize, is duplicate templates. So if you already rendering something
on the server, you want that to be the source of truth, without duplicating the template in the JS
bundle. That's why reusing .hbs is normally better than knockout, you only have to maintain a single
template (still keep them sync between server and client though).

### Adding new items without an existing template

This is similar to the case above, but now we're not sure we have an existing item in the DOM we
could clone. This could be conditionally (depending on which page you're on), or always (you never
render the template on the server at all).
